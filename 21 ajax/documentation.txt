/********************* J S   P R O J E C T S  *********************/

**************************
01-GENERER UN CODE COULEUR
**************************

//Affiche la couleur qui correspond au code 
//hexadecimal (#a5...8) sur 6 caractères (0,1...E, F):
document.body.style.backgroundColor = nbreHex;

//Affiche le code proprement dit (#a5...8)
color.textContent = nbreHex;

*********
04-NAVBAR
*********
=> 1 HTML: Bouton "Hamburger + liste <ul> de classe ".links"
    <button class="nav-toggle">
            <i class="fas fa-bars"></i>
    </button>

     <ul class="links">     //Liste à toggler (montrer/cacher)
        <li >
          <a href="index.html">home</a>
        </li>
        .../..
     </ul>        

=> 2 CSS: 2 classes pour montrer/cacher la liste de classe ".links"
     .links{
        height:0;
        overflow:hidden;
        transition: var(--transition);
     }

     .show-links{       //Cette classe est ajoutée ou supprimée(CSS!!!)
        height:10rem    //Pour 4 adresses <li>
     }
=> 3 JS: 
     const liste = document.querySelector('.links');
     const hamburger = document.querySelector('.nav-toggle');

    //Le(s) bouton(s) reçoivent des écouteurs !!!:
   -31 hamburger.addEventListener('click', function(){
    if(liste.classList.contains('show-links')){
        liste.classList.remove('show-links')
    }else{liste.classList.add('show-links')}
   })
            OU (si un seul bouton, une seule class)

    - 32 hamburger.addEventListener('click', function(){
        //Elmt à montrer/cacher.classList.toggle('CSS'): 
        links.classList.toggle('show-links');        
    })               
        log(links.classList);

********
06-MODAL
********
  A modal is a dialog box/popup window that is displayed on top of
  the current page - Open Modal.
  A widely adopted CSS naming practice is to use "hero" as the 
  class name applied to a site's main banner.

************************************
07-1- QUESTIONS - TRAVERSING THE DOM
************************************
const btns = document.querySelectorAll('.question-btn');
log(btns);

btns.forEach(function(btn){
    btn.addEventListener("click", function(evt){
        log(evt.currentTarget);
        //On "traverse" jusqu'au grand- parent du btn:
        const question = evt.currentTarget.parentElement.parentElement;
        //On ajoute / supprime la classe "show-text" à la classList du grand parent:
        question.classList.toggle("show-text");
    });
});
   
Où "question" est une classe du grand-parent des btns.

***************************************************
07-2 QUESTIONS - USING SELECTORS INSIDE THE ELEMENT
***************************************************
questions.forEach(function(question){
    /* Rechercher le bouton de la seule question (!= document): */
   const btn = question.querySelector('.question-btn');
   /* Ajouter un écouteur à ce seul bouton */
   btn.addEventListener('click', function(){
    /* Parcourir à nouveau la liste des questions (items) */
   questions.forEach(function(item){
    /* Comparer chaque item à la question qui reçoit l'écouteur */
    if(item !== question){
    item.classList.remove('show-text')}
    else {question.classList.toggle('show-text')}
   })
   })
})

********************************
08-DISPLAY ITEMS WHEN PAGE LOADS
********************************
HTML:
        <!-- single item 1 -->
        <article class="menu-item">
          <img src="./menu-item.jpeg" alt="photo" class="photo">
          <div class="item-info">
            <header>
              <h4>butter milk pancakes</h4>
              <h4 class="price">$15</h4>
            </header>
            <p class="item-text" >Lorem ipsum dolor sit amet consectetur adipisicing
               elit. Consequuntur voluptates quae velit? Ea atque 
               maxime soluta. Tempore maxime provident dolorem.</p>
          </div>
        </article>
        <!-- end single item 1 -->

app.js:
const log = console.log;
let displayMenu = []; 
const sectionCenter = document.querySelector('.section-center');
window.addEventListener('DOMContentLoaded', function(){
    displayMenu = menu.map(function(item){
    return `<article class="menu-item">
          <img src=${item.img} alt=${item.title} class="photo">
          <div class="item-info">
            <header>
              <h4>${item.title}</h4>
              <h4 class=${item.price}>$15</h4>
            </header>
            <p>${item.desc}</p>
          </div>
        </article>`
  })
  log(displayMenu);
  displayMenu = displayMenu.join("");
  sectionCenter.innerHTML = displayMenu;
})

***********
08-REFACTOR
***********
L'opération consiste à créer une fonction "displayMenuItems"
qui est paramétrable et peut recevoir n'importe quelle array d'items
dont "menu" qui comprend 9 items:


const sectionCenter = document.querySelector('.section-center');
window.addEventListener('DOMContentLoaded', function(){
    displayMenuItems(menu)              //Appel de la nouvelle fonction
})

function displayMenuItems(menuItems){   //Nouvelle fonction paramétrable
  let displayMenu = menuItems.map(function(item){
    return `<article class="menu-item">
          <img src=${item.img} alt=${item.title} class="photo">
          <div class="item-info">
            <header>
              <h4>${item.title}</h4>
              <h4 class=${item.price}>$15</h4>
            </header>
            <p>${item.desc}</p>
          </div>
        </article>`
  })
  log(displayMenu);
  displayMenu = displayMenu.join("");
  sectionCenter.innerHTML = displayMenu;
}

***************************
08-FILTER BUTTONS STATIQUES
***************************
   data- : data-id, data-category, data-price...these data sets ara attributes of
an element which make the element more specific.
Dans le HTML, example: data-id="breakfast", data-id="all"...on aura:
<button class="filter-btn" type="button" data-id="lunch">lunch</button>
Et dans le JS (app.js):

 const filterBtns = document.querySelectorAll('.filter-btn');
filterBtns.forEach(function(btn){
  btn.addEventListener('click', function(evt){
=>const category = evt.currentTarget.dataset.id;/*category critère de sélection */
  const menuCategory = menu.filter(function(menuItem){
   /* La fonction filter - filtre = category - */
   if(menuItem.category === category)return menuItem;
   })
   /* Display menuCategory */
   if(category === "all") {displayMenuItems(menu)}
   else {displayMenuItems(menuCategory)}
  })
})

*******************
08-FILTER DYNAMIQUE
*******************
=>  Using REDUCE to remove duplicates:
    let categories = menu.map(function(item){
      return item.category;
    })
    log(categories); //(10) ['breakfast', 'lunch', 'shakes', 'breakfast', 
                     //'lunch', 'shakes', 'breakfast', 'lunch', 'shakes', 'dinner']

=>    categories = menu.reduce(function(values, item){
      if(!values.includes(item.category)){
          values.push(item.category)
      }
      return values;  //OBLIGATOIRE !!!
    },["all"])
    log(categories);(5) ['all', 'breakfast', 'lunch', 'shakes', 'dinner']

********
09-VIDEO
********
=>> Création d'un bouton marche/arrêt:
HTML:
  <!-- video switch -->
     <button class="switch-btn">
      <span>play</span>
      <span>pause</span>
      <span class="switch"></span>
     </button>

CSS:
/* switch button */
.switch-btn {
  position: absolute;
  bottom: 7%;
  left: 7%;
  width: 7rem;
  height: 2rem;
  display: flex;
  border-radius: var(--radius);
  align-items: center;
  justify-content: space-around;
  border: none;
  transition: var(--transition);
}
.switch-btn span {
  display: inline-block;
  font-size: 0.85rem;
  cursor: pointer;
  text-transform: capitalize;
  color: var(--clr-primary-5);
}
.switch {
  position: absolute;
  width: 50%;
  height: 100%;
  top: 0;
  left: 0;
  background: var(--clr-primary-5);
  border-radius: var(--radius);
  margin: 0;
  display: block;
  transition: var(--transition);
}

.slide .switch {
  left: 50%;
}     

JS:
const btn = document.querySelector('.switch-btn');
const video = document.querySelector('.video-container');

btn.addEventListener('click', function(){
    if(btn.classList.contains('slide')) {
        btn.classList.remove('slide');
        video.play();
    }else{
        btn.classList.add('slide');
        video.pause();
    }
})

=> Overlay
/* header after - BLACK OVERLAY */
 header::after {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);/* BLACK OVERLAY */
  z-index: -1;
}

=> Preloader:
HTML:
    <div class="preloader">
      <img src="./preloader.gif" alt="preloader">
    </div>

CSS:
.preloader {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: var(--clr-white);
  display: grid;
  justify-content: center;
  align-items: center;
  visibility: visible;
  z-index: 999;
  transition: var(--transition);
}    

.hide-preloader {
  z-index: -999;
  visibility: hidden;
}

JS:
const preloader = document.querySelector('.preloader');
window.addEventListener('load', function(){ /* When ALL files are loaded */
    preloader.classList.add('hide-preloader');
})

******************
10-SCROLL STATIQUE
******************
=> Date:
  JS:
  let date = document.querySelector('#date');
  date.textContent = new Date().getFullYear; //Retourne l'année

=> Access Fontawesome:
HTML (Head):
   <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
   /> 

JS (statique): 
  navToggle.addEventListener('click', function(){
     linksContainer.classList.toggle("show-links");
  })

CSS:
  .show-links{
    height: 200px;  //height of links is fixed !!!
  }

*******************
10-SCROLL DYNAMIQUE
*******************
CSS:
  .fixed-nav .links-container { //links-container wraps links
      height: auto;             //height is dynamic !!!
  }

JS:
  const containerHeight = linksContainer.getBoundingClientRect().height;
    log(containerHeight);   /* 0 */
    const linksHeight = links.getBoundingClientRect().height;
    log(linksHeight);   /* 201.5833 */

    if(containerHeight === 0){linksContainer.style.height = `${linksHeight}px`;}
    else {linksContainer.style.height = 0;}

************************
10-SCROLL - FIXED NAVBAR
************************
const navbar = document.querySelector('#nav');/* <nav> tout en haut du HTML */
log(navbar);
const topLink = document.querySelector('.top-link'); /* <a> tout en bas */
log(topLink)

window.addEventListener('scroll', function(){
    const scrollHeight = window.pageYOffset; log(scrollHeight);
    const navHeight = navbar.getBoundingClientRect().height;
    if(scrollHeight > navHeight){ 
        navbar.classList.add('.fixed-nav');
    }else{
        navbar.classList.remove('.fixed-nav');
    }

    if(scrollHeight > 500){       //Le bouton retour apparait
        topLink.classList.add('show-link');
    }else{
        topLink.classList.remove('show-link');
    }
})

****************
10-SMOOTH SCROLL
****************
// select links
const scrollLinks = document.querySelectorAll('.scroll-link');
//log(scrollLinks);
scrollLinks.forEach(function(link){
    link.addEventListener('click', function(evt){
        evt.preventDefault();/* Bloque le déplacement vers l'adresse sélectionnée */
        //navigate to specific spot
        const id = evt.currentTarget.getAttribute('href').slice(1);     //Retire le '#'
        log('ID: '+ id);
        const element = document.getElementById(id);
        log(element);
        let position = element.offsetTop;
        log('Position:' + position);
        window.scrollTo({
            left:0,
            top:position
        })
        linksContainer.style.height=0;
    })
})


*************************
10-SMOOTH SCROLL COMPLETE
*************************

????

***********
VOCABULAIRE
***********
   element.offsetTop;
   window.pageYOffset;
   window.scrollTo({X, Y})
   evt.currentTarget.getAttribute('href')
   date.textContent, date.innerHTML
   navbar.getBoundingClientRect().height; 
   preventDefault, example:
      <body>
      <a id="myAnchor" href="https://w3schools.com/">Go to W3Schools.com</a>
      <p>The preventDefault() method will prevent the link above from following the URL.</p>

      <script>
        document.getElementById("myAnchor").addEventListener("click", 
             function(event){
              event.preventDefault()
             });
      </script>
      </body>

*******
11-TABS
*******
target vs currentTarget:https://www.youtube.com/watch?v=SpatM1W5wRQ

const main =document.querySelector('main').addEventListener('click', clicked);
const div =document.querySelector('div').addEventListener('click', clicked);

The target is the selector (tag, class or id) which stands before "addEventListener";
The currentTarget is the selector to which the event stopped;

If I click on main: target is main and currentTarget is main; the "clicked"
function is executed once;
If I click on div: target is div, the event bubbles up, the currentTarget is
main; the clicked function gets executed twice.

*********
12-COUNTDOWN
*********
  Deux classes sur un même élément, une classe pour assurer la mise en forme
  et une pour assurer des interactions avec le javascript.

const months = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December",
];
const weekdays = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
];

app.js:
  let futureDate = new Date(2025, 4, 24, 11, 30, 0) /* An, mois, jour, hh, mm, ss */
log(futureDate);
/* Easy */
const year = futureDate.getFullYear();
const hours = futureDate.getHours();
const minutes = futureDate.getMinutes();
const date = futureDate.getDate();  /* jour du mois */
log(date);
/* Not so easy */
const monthNumber = futureDate.getMonth(); /* A number 0 to 11*/
const month = months[monthNumber];
log(month);
const weekdayNumber = futureDate.getDay();
const weekDay = weekdays[weekdayNumber];
log(weekDay);                       /* jour de la semaine  */

giveaway.textContent = `Give away ends on ${weekDay} ${date} ${month},${year}, 
${hours}:${minutes} am`;
log(giveaway.textContent);  

/* Calcul du délai entre aujourd'hui et une date future */
//Fonction calcul du temps  restant à une date
let remainingTime = function(futureDate){
  let futureTime = futureDate.getTime();
  log('Date limite: ' + futureTime); 
  let presentTime = (new Date()).getTime();
  log('Date du jour: ' + presentTime)
  
//Transforme délai de millisecondes en jrs hrs mins et secondes
t = futureTime- presentTime;
log(`T:${t}`)
const day = 24 * 60 * 60 * 1000; const hr = 60 * 60 *1000;const mn = 60000;
let days = Math.floor(t/day);// log(`Jours entiers restant ${days}`);
let tRestant = t%day;        //log(`Heures restantes en ms: ${tRestant}`);
//log(`ctrl: ${(days*day + tRestant)}`)
let hrs = Math.floor(tRestant/hr); //log(`Heures entières: ${hrs}`);
tRestant = tRestant%hr; //log(`Minutes restantes en ms: ${tRestant}`);
let mns = Math.floor(tRestant/mn); //log(`Minutes entières ${mns}`);
tRestant = tRestant%mn; //log(`Secondes restantes en ms: ${tRestant}`);
let secondes = tRestant /1000; //log(`Secondes: ${secondes}`);
secondes = Math.ceil(secondes);
let controle = secondes*1000 + mns*60000 + hrs*hr + days*day;
log(`Controle: ${controle}`);

//Affichage du temps restant "t"
let values = [days, hrs, mns,secondes];
items.forEach(function(item, index){  //index: optional donne le rang (0 à 3)
  item.textContent = values[index];
})
}//FIN 1ERE BOUCLE remainingTime

/* LANCEMENT DE LA BOUCLE calcul */
let calcul = function(){remainingTime(new Date(2026, 10, 15, 12, 0, 0));}
setInterval(calcul, 1000);

clearInterval(calcul);//Bouton arrêt à créer

**************
13-LOREM IPSUM
**************
Input element is always a String => use parseInt(String) to extract a number. 
La saisie d'un input apparait en noir s'agissant d'un String puis tourne au bleu
après utilisation de parseInt().

*******************
14-GROCERY ADD ITEM
*******************
=> Convertir une nodeList en Array

// Récupération de tous les éléments ayant la classe "exemple" dans un NodeList
const nodeListName = document.querySelectorAll('.exemple');

// Conversion du NodeList en Array grâce au spread operator
const arrayName = [...nodeListName];

// Affichage du résultat dans la console pour vérification
console.log(arrayName);

Example:
log(grocery.attributes);
let groceryArray = [...grocery.attributes];
for(let i=0; i < groceryArray.length; i++){
    log(groceryArray[i].value);
}

=> FORMS
https://www.w3schools.com/html/html_forms.asp

A form element is a container for different types of form elements:
The HTML <form> element can contain one or more of the following form elements:

    <input>        id
    <label>        for
    <select>       The <select> element defines a drop-down list: <option>
    <textarea>     
    <button>
    <fieldset>
    <legend>
    <datalist>
    <output>
    <option>
    <optgroup>

The HTML <input> element is the most used form element.
An <input> element can be displayed in many ways called "types": 
Examples of type attribute <input type="text", radio, 
checkbox, submit, button....>.

The input element has attributes:
    value : The input value attribute specifies an initial value 
            for an input field.
    readonly
    disabled

=> CREER UN ELEMENT DYNAMIQUEMENT et lui attacher une classe, 
   un attribut et un innerHTML:
  const element = document.createElement('article');
   //add classList
   element.classList.add('grocery-item');
   //add attribute data-id
   const attr = document.createAttribute('data-id');
   attr.value = id; (L'heure en millisecondes)
   element.setAttributeNode(attr); 
   //add element to HTML
   element.innerHTML = `<p class="title">${value}</p>
            <div class="btn-container">
              <button type="button" class="edit-btn">
                <i class="fas fa-edit"></i>
              </button>
              <button type="button" class="delete-btn">
                <i class="fas fa-trash"></i>
              </button>
            </div>`    

=> NODES- Different types of node: element node, comment node, text node...  
          Children only include element nodes, whereas childnodes include 
          all types of nodes. 

    previousSibling => any type of sibling;
    previousElementSibling => first sibling of element type;

    EXAMPLE: const element = evt.currentTarget.parentElement
                             .previousElementSibling;
    The currentTarget is a <button> (.edit-btn) : currentTarget
    child of <div> (.btn-container):              parentElement
    which is sibling of <p> (.title):             previousElementSibling
    
=> innerHTML, textContent, innertext

    https://builtin.com/software-engineering-perspectives/innerhtml-vs-innertext

  JavaScript, the innerHTML property returns HTML markup, or all text content
  of an element (including spacing and HTML tags). 
  The innerText property shows visible rendered text, or the text content 
  of an element (without spacing, CSS hidden text and HTML tags). 
  The textContent property retrieves raw text, or the text content 
  of an element (including spacing and CSS hidden text, but no HTML tags).

                  HTML    TEXT CONTENT    SPACING   FORMATING

      InnerHTML     X           X             X         X

      InnerText     NO          X             NO        NO

      TextContent   NO          X             X         X

=> Value property: The value property sets or returns 
   the value of the value attribute of a text field.     

   Example: <input type="text" id="grocery".../> donne grocery.value 
   
   Return the value property: textObject.value

   Set the value property:  textObject.value = text

=> Local storage:   
    setItem,
    getItem,
    removeItem.

    All the data is stored as String.
    Examples:
        localStorage.setItem('orange', JSON.stringify['item1', 'item2']);
        const oranges = JSON.parse(localStorage.getItem('orange'))
        localStorage.removeItem('orange');

*********
15-SLIDER
*********
   The slider-container uses position relative.  
   Each slide uses position absolute and covers the previous slide.
   At the start only the last slide is displayed on the screen.

   .slider-container has "overflow: hidden;" property so that only one
   slide can be seen at a time.

*******
DATASET
*******
Méthodes: Element.getAttribute(), setAttribute(), removeAttribute(), hasAttribute();

Tout attribut d'un élément dont le nom commence par data- 
est un attribut de données (data attribute)

<article
  id="voitureelectrique"
  data-columns="3"
  data-index-number="12314"
  data-parent="voitures">
  ...
</article>

Vous pourriez utiliser getAttribute() avec leur nom HTML complet pour les lire.
De manière plus simple : un DOMStringMap peut être lu via une propriété dataset:

var article = document.getElementById("voitureelectrique");

- Accéder aux attributs via le JS:
    article.dataset.columns; // "3"
    article.dataset.indexNumber; // "12314" index-number devient indexNumber !!!
    article.dataset.parent; // "voitures"

- Accéder via le CSS:
    article[data-columns="3"] {
      width: 400px;
    }
    
    article[data-columns="4"] {
      width: 600px;
    }

*******
OBJECTS
*******
VOIR LE COURS JS TUTORIAL

****
THIS
****
https://www.youtube.com/watch?v=Z3M4CV5tLnY

-1 This dans la portée globale:
function getThis(){
    return this;
}
log(getThis()); //window

  Donc THIS pointe sur window.

-2 Call back d'un gestionnaire d'événement
const btn = document.querySelector('.monBtn'); log(btn);

btn.addEventListener('click', function(){
    log('Type of THIS: ' + typeof(this)); // Object
    log(this);                            // <button class="monBtn">MON BOUTON</button>
})
  Donc THIS pointe sur le bouton "btn".

-3 Avec un new (Cas d'un Prototype ou d'une Class):
const obj = new Obj{
    constructor(){
        log(this);    //Obj {}
    }
}

const obj = new Obj;    //obj pointe sur Obj{}, le "modèle"

-4 Avec une méthode d'un objet
const monBtn = document.querySelector('.monBtn');
           
class Obj{
    constructor(){
        this.click= false;
        this.set = function(){
            log(this);          //Obj{click:false, set:f}
            this.click = true;
        }
    }
}

const obj = new Obj;    

monBtn.addEventListener('click', obj.set);          //this pointe sur monBtn
monBtn.addEventListener('click', obj.set.bind(obj));//this pointe sur Obj

bind déplace le pointeur de monBtn sur Obj;


https://www.youtube.com/watch?v=6tC4tv9MlkI (Les classes)

*****************
PROTOTYPE BINDING
*****************
EX1:
let geek1 = {
    prop1() {
        return 'Object.isExtensible()';
    },
    prop2() {
        return 'JavaScript ';
    }
}
let geek2 = {
    prop3() {
        return 'Geeksforgeeks';
    }
}   

Object.setPrototypeOf(geek2, geek1);   //geek2 reçoit les propriétés et méthodes de geek1  
+++++++++++++++++++++++++++++++++++
console.dir(geek2);                    //liste les propriétés et méthodes de geek2
console.log(geek2.prop3());
console.log(geek2.prop2());
console.log(geek2.prop1());

Output:
  "Geeksforgeeks"
  "JavaScript "
  "Object.isExtensible()"

***************
PROTOTYPE CHAIN
***************
const parent = {
    species:'Human',
    breathe:() => {log('Breathing')}
}
log(parent);

const enfant = Object.create(parent); //"Object attache enfant à parent"  
      ++++++++++++++++++++++++++++++
enfant.nom = 'Georges';
enfant.age = 70;
log(enfant);

const petitEnfant = Object.create(enfant)  //"Object attache petitEnfant à enfant"
      +++++++++++++++++++++++++++++++++++
log(petitEnfant);
petitEnfant.age = 5;


log(petitEnfant.age);     //5
log(petitEnfant.nom);     //Georges
log(petitEnfant.species); //Human

*****************
FACTORY FUNCTIONS (Sans PROTOTYPE ?,  sans NEW )
*****************
A function that creates and returns new objects. These objects share common properties and methods.
To create a few objects use object literals. But to create many use a factory function.



//FACTORY
Ex1:
function createPerson(name){
    return {
        name,
        talk: function () {return `I am ${name}`} 
    }
}

const moi = createPerson('Georges');
const toi = createPerson('Arthur');

log(moi.talk());
log(toi.name);

Ex2:
The code works perfectly fine. However, in practice, you will rarely use the factory functions. 
Instead, you use classes or constructor/prototype patterns.

var personActions = {
    +++++++++++++
    getFullName() {
      return this.firstName + ' ' + this.lastName;
    },
};

function createPerson(firstName, lastName) {
  let person = Object.create(personActions);
               ++++++++++++++++++++++++++++
  person.firstName = firstName;
  person.lastName = lastName;
  return person;
}

let person1 = createPerson('John', 'Doe');
let person2 = createPerson('Jane', 'Doe');

console.log(person1.getFullName());
console.log(person2.getFullName());   

*******
CLASSES (avec CONSTRUCTOR + NEW + THIS + PROTOTYPE -sous entendu-)
*******
  Classes are a syntactic sugar of constructors in Javascript.

  Notice that instead of adding increment and login methods on the prototype explicitly,
  we nicely tuck them inside the class object though under the hood 
  they are added to the prototype(implicitly).
           ++++++++++++++++++++++++++++++++++
class playerCreator{
+++++
  constructor(name,score){
  +++++++++++
  this.name = name;
  this.score = score;
  }

increment: function () {
  this.score++;
};

login:  function () {
  this.login = false;
};
}

***********
CONSTRUCTOR (avec THIS + NEW + PROTOTYPE)
*********** 
Les fonctions constructeur sont techniquement des fonctions habituelles. 
Il existe cependant deux conventions :

    Elles sont nommées avec une lettre majuscule en premier.
    Elles ne devraient être executées qu’avec l’opérateur "new".

Quand une fonction est exécutée avec new, elle effectue les étapes suivantes :

    Un nouvel objet vide est créé et affecté à this.
    Le corps de la fonction est exécuté. Habituellement, il modifie this, y ajoutant de nouvelles propriétés.
    La valeur de this est retournée.

En d’autres termes, new User(...) fait quelque chose comme :

function User(name) {
  // this = {};  (implicitement)

  // ajoute des propriétés à this
  this.name = name;
  this.isAdmin = false;

  // return this;  (implicitement)
}

Ex1:    
function playerCreator(name, score) {
  this.name = name;
  this.score = score;
}

playerCreator.prototype.increment = function () {
  this.score++;
};
playerCreator.prototype.login = function () {
  this.login = false;
};

  The increment and login functions are placed on the prototype.
                                    +++++++++++++++++++++++++++
  They are shared functions so any object created by the constructor
  has access to the methods. This saves memory.
  
  ************
  19-DARK-MODE
  ************
  elmt.classList.add('class1', 'class2');
  elmt.classList.remove('class2');
  elmt.classList.toogle('class1');
  elmt.classList.contains('class3');
  elmt.className = "";			//removes all classes
  elmt.hasAttribute('class');		//true
  elmt.removeAttribute('class');
  elmt.setAttribute('class');
  
  
  Libraries: https://cdnjs.com
  	     cdnjs moment.js
  	     
  	     
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.30.1/moment.min.js" integrity="sha512-hUhvpC5f8cgc04OZb55j0KNGh4eh7dLxd/dPSJ5VyzqDWxsayYbojWyl5Tkcgrmb/RVKCRJI1jNlRbVP4WWC4w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  	  
**********  	  
20-FILTERS
**********
    =>Faire une copie d'un fichier:
	let filteredProducts = [...products];    /* Fait une copie du fichier products.js */

    =>Extraire et afficher les données du fichier:
	const displayProducts = () => {
	//if statement

    	productsContainer.innerHTML = filteredProducts.map(({id, title, image, price}) => {
        return`<article class="product" data-id = "${id}">
           <img src="${image}" 
           alt="" class="product-img img">
           <footer>
            <h5 class="product-name">${title}</h5>
            <span class="product-price">${price}</span>
           </footer>
         </article>`
    })
 }

 	displayProducts();
 	
    => includes
    	let text = "Hello world, welcome to the universe.";
	let result = text.includes("world");		//true
	
    => a set
    	Set objects are collections of values. 
    	A value in the set may only occur once; 
    	it is unique in the set's collection.
    	
    	https://www.w3schools.com/js/js_sets.asp
    	
    => event.target: The target property returns the element where the event occured.
       		     const element = event.target;
       		     let text = event.target.tagName; //The name of the targeted element
       
       currentTarget: returns the element whose event listener triggered the event.       
       
    => data-*
    
       Exemple: <article
  		  id="voitureelectrique"
  		  data-columns="3"
  		  data-index-number="12314"
  		  data-parent="voitures">
  		  ...
		</article>
		
	Accéder aux attributs data- avec JS :
		var article = document.getElementById("voitureelectrique");
		article.dataset.columns; 	// "3"
		article.dataset.indexNumber; 	// "12314"
		article.dataset.parent; 	// "voitures"
		
	Accéder aux attributs data- avec CSS :		
		article[data-columns="3"] {
  		  width: 400px;
		}
		
		article[data-columns="4"] {
  		  width: 600px;
		}

**********************
20-BIS MODULES (COURS)
**********************
=> Extraire les propriétés d'un objet:
	
	const {fname, job} = person où person est un objet composé de 2 propriétés
	
=> named export ...	

  <script defer type="module" src="./app.js"></script> !! Il faut préciser type = "module"
  
  In data.js:
  export const random = 'A random value'; 
  
  In app.js:
  import {random} from '.utils/data.js';
  log(random);		//'A random value'
  
  => ... and default export
  Quel intérêt ? Pouvoir utiliser un nom par défault dans app.js au lieu de celui de data.js
  Un seul "default export" !
  
  **********************
  20-Ter ASYNCHRONOUS JS
  **********************
  	With synchronous code lines  are executed one after the other.
  	
	=> Functionalities provided by the browser: setTimeout, Fetch Data, Get Geolocation, setTimer...
  	
  	=> Callback hell
  	
  	=> The setTimeout() method calls a function after a number of milliseconds. 1 second = 1000 milliseconds. 
  	    Notes: The setTimeout() is executed only once.
  	
  	=> Example of asynchronous code:
  
  
/* JS launchess boilWater function for minimum 20 seconds  */
boilWater(20000);
/* JS moves to next task & keeps browser waiting */
for(i = 0; i < 20000; i++){
    log('Chop carrots');
}

function boilWater(time) {
/* The browser executes this log and waits for JS 
to finish choping the carrots */    
    log('Water is boiling...')
/* The browser comes back to JS asking for execution of setTimeout 
after 20 seconds minimum. If 'Chop carrots' loop is not yet done the 
browser waits for JS to finish */    
    setTimeout(() => {log('Done')}, time);
}
  
  	=> Promises : pending, resolve, reject.
  
  
  ****************
  20-6 ASYNC AWAIT
  ****************
  2 FAÇONS D'ÉCRIRE:
  
  REGULAR:
  async function someFunction () {
  await
    .../..code
  }
  
  OR
  
  ARROW:
  const otherFunction = async() => {
  await
	.../.. code
  }
  
*******
21 AJAX
*******
Asynchronous JAvascript and XML
Originaly ajax used XML but today it uses JSON

1-const xhr = new XMLHttpRequest();   //Créer une requête
2-xhr.open('GET','./api/sample.txt'); //Ouvrir un fichier sur le serveur
3-Dans le browser, taper:http://127.0.0.1:5500/api/sample.txt
  pour vérifier le contenu du fichier.

  Different states of the request:

const xhr = new XMLHttpRequest();
console.log("UNSENT", xhr.readyState); // readyState will be 0

xhr.open("GET", "/api", true);
console.log("OPENED", xhr.readyState); // readyState will be 1

xhr.onprogress = () => {
  console.log("LOADING", xhr.readyState);//readyState will be 3
};

xhr.onload = () => {
  console.log("DONE", xhr.readyState); // readyState will be 4
};

xhr.send(null);

The request can be with or without credentials

Properties of the XMLHttpRequest: readyState, status, statusText,
response, responseText.

